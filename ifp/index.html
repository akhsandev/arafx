<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Eco-Guardian: Physics Defender (IFP Edition)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Rajdhani', sans-serif;
            color: white;
            user-select: none;
            /* OPTIMASI IFP: Mencegah browser melakukan zoom/scroll default pada sentuhan */
            touch-action: none; 
            -webkit-touch-callout: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Let clicks pass through to game */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .score-box {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            padding: 10px 20px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .score-title {
            font-size: 0.8rem;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .score-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: bold;
        }

        /* Boss Health Bar - Scale up slightly for big screens */
        #boss-hud {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 70%; 
            display: none; /* Hidden initially */
            flex-direction: column;
            align-items: center;
        }

        .boss-name {
            color: #ff0055;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ff0055;
            text-align: center;
        }

        .health-bar-container {
            width: 100%;
            height: 30px; /* Thicker for visibility on IFP */
            background: rgba(50, 0, 0, 0.5);
            border: 3px solid #ff0055;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        #boss-health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0055, #ff5500);
            transition: width 0.5s ease-out;
            box-shadow: 0 0 15px #ff0055;
        }

        /* Start Screen & Modals */
        #modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(10, 20, 40, 0.95), rgba(0, 0, 0, 0.95));
            border: 2px solid #00ffff;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 700px; /* Wider for IFP readability */
            width: 90%;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, #00ffff, #0088ff, #00ffff);
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            margin-top: 0;
            font-size: 2.5rem; /* Bigger title */
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        p {
            font-size: 1.3rem; /* Bigger text for classroom viewing */
            line-height: 1.6;
            color: #ccc;
        }

        .btn {
            background: transparent;
            border: 3px solid #00ffff; /* Thicker border */
            color: #00ffff;
            padding: 15px 40px; /* Larger touch target */
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            margin-top: 30px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            border-radius: 8px;
        }

        .btn:hover, .btn:active {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }

        /* Quiz Specific Styles */
        .quiz-option {
            display: block;
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            padding: 20px; /* Larger padding for touch */
            margin: 15px 0;
            text-align: left;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 8px;
            color: white;
            font-size: 1.2rem; /* Readable from back of class */
        }

        .quiz-option:hover, .quiz-option:active {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
        }

        .correct-anim {
            animation: pulse-green 0.5s;
            background: rgba(0, 255, 0, 0.2) !important;
            border-color: #00ff00 !important;
        }

        .wrong-anim {
            animation: shake 0.5s;
            background: rgba(255, 0, 0, 0.2) !important;
            border-color: #ff0000 !important;
        }

        @keyframes pulse-green {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        .hidden {
            display: none !important;
        }

        /* Mobile controls hint */
        .controls-hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1rem;
            pointer-events: none;
            background: rgba(0,0,0,0.5); /* Background for readability */
            padding: 5px 0;
        }

        /* Tutorial/Explanation text */
        .explanation-text {
            font-size: 1.1rem;
            color: #00ffaa;
            margin-top: 15px;
            font-style: italic;
            display: none;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">
                <div class="score-title">SKOR</div>
                <div class="score-value" id="score-display">0</div>
            </div>
            <div class="score-box" style="border-color: #ff0055; box-shadow: 0 0 10px rgba(255, 0, 85, 0.3);">
                <div class="score-title" style="color: #ff0055;">NYAWA</div>
                <div class="score-value" id="player-hp-display">100%</div>
            </div>
        </div>
        
        <div id="boss-hud">
            <div class="boss-name">TITAN POLUSI (BOSS)</div>
            <div class="health-bar-container">
                <div id="boss-health-fill"></div>
            </div>
        </div>

        <div class="controls-hint">Sentuh & Geser Layar untuk Menggerakkan Pesawat • Pesawat Menembak Otomatis saat Disentuh</div>
    </div>

    <!-- Modals -->
    <div id="modal-overlay">
        <!-- Start Screen -->
        <div id="start-screen" class="modal-content">
            <h1>ECO-GUARDIAN</h1>
            <p>Bumi sedang diserang oleh armada <strong>Titan Polusi</strong>. Kalahkan pasukan musuh dan hancurkan Bos Utama.</p>
            <p style="font-size: 1.1rem; color: #aaa;">Bos memiliki perisai yang hanya bisa ditembus dengan pengetahuan tentang <strong>Energi Terbarukan</strong>.</p>
            <button class="btn" onclick="startGame()">MULAI MISI</button>
        </div>

        <!-- Quiz Screen -->
        <div id="quiz-screen" class="modal-content hidden">
            <h2 id="quiz-title" style="color: #ffff00; text-transform: uppercase;">Analisis Energi</h2>
            <p id="quiz-question">Pertanyaan akan muncul di sini...</p>
            <div id="quiz-options">
                <!-- Options generated by JS -->
            </div>
            <div id="quiz-explanation" class="explanation-text"></div>
            <button id="quiz-continue-btn" class="btn hidden" onclick="closeQuiz()">Lanjutkan Serangan</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="modal-content hidden">
            <h1 id="go-title">MISI GAGAL</h1>
            <p id="go-message">Pesawat hancur.</p>
            <div style="margin: 20px 0; font-size: 3rem; color: #00ffff;" id="final-score">0</div>
            <button class="btn" onclick="location.reload()">Coba Lagi</button>
        </div>
    </div>

    <!-- 3D Canvas Container -->
    <div id="game-container"></div>

    <script>
        // --- IFP OPTIMIZATION: PREVENT CONTEXT MENU ---
        // Mencegah menu klik kanan muncul saat layar ditekan lama (Long Press)
        document.addEventListener('contextmenu', event => event.preventDefault());

        // --- GAME CONFIGURATION & STATE ---
        const config = {
            playerSpeed: 0.15,
            bulletSpeed: 0.5,
            enemySpeed: 0.08,
            bossSpeed: 0.02,
            spawnRate: 60, // frames
        };

        const state = {
            isPlaying: false,
            isPaused: false,
            score: 0,
            playerHP: 100,
            level: 1, // 1: Minions, 2: Boss
            bossHP: 100,
            bossMaxHP: 500, // Boss takes a lot of hits
            frames: 0,
            bossPhase: 0, // 0: 100%, 1: 75%, 2: 50%, 3: 25%, 4: 0%
            mouse: { x: 0, y: 0 },
            isShooting: false
        };

        // --- THREE.JS VARIABLES ---
        let scene, camera, renderer;
        let player, boss;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let starField;

        // --- PHYSICS/QUIZ DATA ---
        const quizData = [
            {
                threshold: 100,
                question: "Bos tiba! Perisainya aktif. Apa definisi energi terbarukan yang paling tepat?",
                options: [
                    "Energi yang berasal dari fosil dan terbatas.",
                    "Energi yang berasal dari proses alam yang berkelanjutan.",
                    "Energi yang hanya bisa digunakan di siang hari.",
                    "Energi buatan manusia dari reaksi kimia berbahaya."
                ],
                correct: 1,
                explanation: "Energi terbarukan berasal dari sumber alam (matahari, angin, air) yang terus diperbarui secara alami."
            },
            {
                threshold: 75,
                question: "Perisai 75%! Panel surya mengubah energi cahaya menjadi listrik menggunakan efek apa?",
                options: [
                    "Efek Rumah Kaca",
                    "Efek Doppler",
                    "Efek Fotovoltaik",
                    "Efek Piezoelektrik"
                ],
                correct: 2,
                explanation: "Sel surya menggunakan efek Fotovoltaik, di mana foton cahaya melepaskan elektron dari material semikonduktor."
            },
            {
                threshold: 50,
                question: "Perisai 50%! Pada Pembangkit Listrik Tenaga Bayu (Angin), perubahan energi apa yang terjadi?",
                options: [
                    "Energi Kimia → Energi Listrik",
                    "Energi Kinetik → Energi Mekanik → Energi Listrik",
                    "Energi Panas → Energi Listrik",
                    "Energi Potensial → Energi Kinetik"
                ],
                correct: 1,
                explanation: "Angin (Kinetik) memutar turbin (Mekanik) yang kemudian memutar generator untuk menghasilkan Listrik."
            },
            {
                threshold: 25,
                question: "Perisai 25%! Apa keunggulan utama energi Geothermal (Panas Bumi) dibanding tenaga surya?",
                options: [
                    "Lebih murah instalasinya",
                    "Tidak bergantung pada cuaca (stabil 24 jam)",
                    "Bisa dipasang di atap rumah",
                    "Tidak memerlukan peralatan khusus"
                ],
                correct: 1,
                explanation: "Geothermal memiliki faktor kapasitas tinggi (Base Load) karena panas bumi tersedia terus-menerus, tidak seperti matahari yang ada malam/siang."
            },
            {
                threshold: 5, // Near death
                question: "Finishing Move! Manakah di bawah ini yang BUKAN merupakan sumber energi terbarukan?",
                options: [
                    "Biomassa",
                    "Batubara",
                    "Hidroelektrik (Air)",
                    "Energi Pasang Surut"
                ],
                correct: 1,
                explanation: "Batubara adalah bahan bakar fosil yang butuh jutaan tahun untuk terbentuk dan menghasilkan emisi karbon tinggi."
            }
        ];

        let currentQuizIndex = 0;

        // --- INIT FUNCTION ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 20;
            camera.position.y = 10;
            camera.rotation.x = -0.3;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            
            // Create Objects
            createStarfield();
            createPlayer();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            
            // IFP / Touch Specific Events
            // Passive false is important to allow preventDefault (stops scrolling)
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            
            // Mouse Interactions
            document.addEventListener('mousedown', () => state.isShooting = true);
            document.addEventListener('mouseup', () => state.isShooting = false);
            
            // Touch Interactions (Multi-touch support for shooting while moving)
            document.addEventListener('touchstart', (e) => { 
                state.isShooting = true; 
                onTouchMove(e); 
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                if(e.touches.length === 0) state.isShooting = false; 
            });

            animate();
        }

        // --- OBJECT CREATION ---
        function createPlayer() {
            const geometry = new THREE.ConeGeometry(1, 3, 4); // Futuristic wedge
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, 
                emissive: 0x0044aa, 
                roughness: 0.2, 
                metalness: 0.8,
                flatShading: true 
            });
            player = new THREE.Mesh(geometry, material);
            player.rotation.x = -Math.PI / 2; // Point forward
            player.rotation.y = Math.PI / 4; // Flat side up
            player.position.y = -8;
            scene.add(player);

            // Engine glow
            const glowGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.y = -1.5;
            player.add(glow);
        }

        function createEnemy() {
            const geometry = new THREE.TetrahedronGeometry(1.2);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff0055, 
                emissive: 0x440022, 
                roughness: 0.1,
                metalness: 0.6
            });
            const enemy = new THREE.Mesh(geometry, material);
            
            // Random start X
            const x = (Math.random() - 0.5) * 30;
            enemy.position.set(x, -8, -50); // Start far back
            enemy.position.y = -8; // Same plane as player generally
            
            // Add custom properties
            enemy.userData = { 
                hp: 1, 
                velocity: new THREE.Vector3(0, 0, (Math.random() * 0.2) + 0.3),
                rotSpeed: (Math.random() - 0.5) * 0.1
            };
            
            enemies.push(enemy);
            scene.add(enemy);
        }

        function createBoss() {
            const geometry = new THREE.IcosahedronGeometry(4, 1);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xff0000, 
                emissive: 0x550000,
                specular: 0xffffff,
                shininess: 50,
                flatShading: true
            });
            boss = new THREE.Mesh(geometry, material);
            boss.position.set(0, -5, -60); // Start far
            
            // Boss rings
            const ringGeo = new THREE.TorusGeometry(6, 0.2, 8, 50);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, wireframe: true });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            boss.add(ring);
            boss.userData = { ring: ring };

            scene.add(boss);
        }

        function createBullet() {
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 2);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const bullet = new THREE.Mesh(geometry, material);
            
            bullet.position.copy(player.position);
            bullet.position.z -= 1; // Start slightly in front
            
            bullets.push(bullet);
            scene.add(bullet);
        }

        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 1000; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200 - 50
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
            starField = new THREE.Points(geometry, material);
            scene.add(starField);
        }

        function createExplosion(position, color) {
            const particleCount = 15;
            const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const material = new THREE.MeshBasicMaterial({ color: color });

            for (let i = 0; i < particleCount; i++) {
                const part = new THREE.Mesh(geometry, material);
                part.position.copy(position);
                part.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5),
                        (Math.random() - 0.5),
                        (Math.random() - 0.5)
                    ),
                    life: 1.0
                };
                particles.push(part);
                scene.add(part);
            }
        }

        // --- GAME LOGIC ---

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('modal-overlay').classList.add('hidden'); 
            state.isPlaying = true;
            state.score = 0;
            state.playerHP = 100;
            state.level = 1;
            updateHUD();
        }

        function updateHUD() {
            document.getElementById('score-display').innerText = state.score;
            document.getElementById('player-hp-display').innerText = state.playerHP + "%";
            
            if (boss && state.level === 2) {
                const percent = (state.bossHP / state.bossMaxHP) * 100;
                document.getElementById('boss-health-fill').style.width = percent + "%";
            }
        }

        function onMouseMove(event) {
            // Normalized device coordinates -1 to +1
            state.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            state.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onTouchMove(event) {
            event.preventDefault(); // Prevent scrolling on IFP
            const touch = event.touches[0];
            state.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            state.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        }

        function checkBossThresholds() {
            if (!boss || state.level !== 2) return;

            const hpPercent = (state.bossHP / state.bossMaxHP) * 100;
            
            let targetIndex = -1;

            if (state.bossPhase === 0) targetIndex = 0; 
            else if (state.bossPhase === 1 && hpPercent <= 75) targetIndex = 1;
            else if (state.bossPhase === 2 && hpPercent <= 50) targetIndex = 2;
            else if (state.bossPhase === 3 && hpPercent <= 25) targetIndex = 3;
            else if (state.bossPhase === 4 && hpPercent <= 5) targetIndex = 4;

            if (targetIndex !== -1 && targetIndex < quizData.length) {
                triggerQuiz(targetIndex);
                state.bossPhase++; 
            }
        }

        function triggerQuiz(index) {
            state.isPaused = true;
            state.isPlaying = false;
            
            const q = quizData[index];
            const overlay = document.getElementById('modal-overlay'); 
            const modal = document.getElementById('quiz-screen');
            const questionEl = document.getElementById('quiz-question');
            const optionsEl = document.getElementById('quiz-options');
            const explainEl = document.getElementById('quiz-explanation');
            const continueBtn = document.getElementById('quiz-continue-btn');

            overlay.classList.remove('hidden'); 
            modal.classList.remove('hidden');
            explainEl.style.display = 'none';
            continueBtn.classList.add('hidden');
            
            questionEl.innerText = q.question;
            optionsEl.innerHTML = ''; 

            q.options.forEach((opt, i) => {
                const btn = document.createElement('div');
                btn.className = 'quiz-option';
                btn.innerText = opt;
                btn.onclick = () => handleAnswer(i, index, btn);
                optionsEl.appendChild(btn);
            });
        }

        function handleAnswer(choiceIndex, quizIndex, btnElement) {
            if (document.getElementById('quiz-continue-btn').classList.contains('hidden') === false) return;

            const q = quizData[quizIndex];
            const explainEl = document.getElementById('quiz-explanation');
            const continueBtn = document.getElementById('quiz-continue-btn');

            if (choiceIndex === q.correct) {
                btnElement.classList.add('correct-anim');
                explainEl.style.color = "#00ffaa";
                explainEl.innerText = "BENAR! " + q.explanation;
                state.score += 500;
            } else {
                btnElement.classList.add('wrong-anim');
                const opts = document.getElementById('quiz-options').children;
                opts[q.correct].style.border = "1px solid #00ff00";
                
                explainEl.style.color = "#ff5555";
                explainEl.innerText = "SALAH. " + q.explanation;
                state.playerHP -= 10;
                updateHUD();
            }

            explainEl.style.display = 'block';
            continueBtn.classList.remove('hidden');
        }

        function closeQuiz() {
            document.getElementById('quiz-screen').classList.add('hidden');
            document.getElementById('modal-overlay').classList.add('hidden'); 
            state.isPaused = false;
            state.isPlaying = true;
            
            if (state.bossPhase === 5) { 
                 state.bossHP = 1; 
            }
        }

        function gameOver(victory) {
            state.isPlaying = false;
            const overlay = document.getElementById('modal-overlay'); 
            const screen = document.getElementById('game-over-screen');
            const title = document.getElementById('go-title');
            const msg = document.getElementById('go-message');
            
            overlay.classList.remove('hidden'); 
            screen.classList.remove('hidden');
            document.getElementById('final-score').innerText = state.score;

            if (victory) {
                title.innerText = "MISI SUKSES";
                title.style.color = "#00ff00";
                msg.innerText = "Titan Polusi telah dikalahkan. Bumi kembali bersih.";
            } else {
                title.innerText = "MISI GAGAL";
                title.style.color = "#ff0000";
                msg.innerText = "Energi pesawat habis.";
            }
        }

        // --- MAIN ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Move stars always
            starField.rotation.z += 0.002;

            if (!state.isPlaying && !state.isPaused) {
                return;
            }

            if (state.isPaused) return;

            state.frames++;

            // 1. Move Player
            const targetX = state.mouse.x * 20;
            player.position.x += (targetX - player.position.x) * 0.1;
            player.rotation.z = -(targetX - player.position.x) * 0.1;

            // 2. Shooting
            if (state.isShooting && state.frames % 10 === 0) {
                createBullet();
            }

            // 3. Move Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.z -= config.bulletSpeed; 
                if (b.position.z < -100) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
            }

            // 4. Level Management
            if (state.level === 1) {
                if (state.frames % config.spawnRate === 0) {
                    createEnemy();
                }

                if (state.score >= 1000 && enemies.length === 0) {
                    state.level = 2;
                    createBoss();
                    document.getElementById('boss-hud').style.display = 'flex';
                    triggerQuiz(0);
                    state.bossPhase = 1;
                }
            } else if (state.level === 2 && boss) {
                if (boss.position.z < -20) {
                    boss.position.z += 0.2; 
                } else {
                    boss.position.x = Math.sin(state.frames * 0.01) * 10;
                    boss.position.y = -5 + Math.cos(state.frames * 0.02) * 2;
                }
                
                boss.rotation.y += 0.01;
                boss.userData.ring.rotation.x += 0.02;
                boss.userData.ring.rotation.y += 0.02;

                checkBossThresholds();
            }

            // 5. Move Enemies & Collisions
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.position.z += config.enemySpeed * 5; 
                e.rotation.x += e.userData.rotSpeed;
                e.rotation.y += e.userData.rotSpeed;

                if (e.position.z > -8 && Math.abs(e.position.x - player.position.x) < 2) {
                    createExplosion(e.position, 0xff0055);
                    scene.remove(e);
                    enemies.splice(i, 1);
                    state.playerHP -= 10;
                    updateHUD();
                    if(state.playerHP <= 0) gameOver(false);
                    continue;
                }

                if (e.position.z > 5) { 
                    scene.remove(e);
                    enemies.splice(i, 1);
                    continue;
                }

                for (let j = bullets.length - 1; j >= 0; j--) {
                    const b = bullets[j];
                    if (b.position.z < e.position.z && b.position.z > e.position.z - 2) {
                        if (Math.abs(b.position.x - e.position.x) < 2) {
                            createExplosion(e.position, 0xffaaff);
                            scene.remove(e);
                            enemies.splice(i, 1);
                            
                            scene.remove(b);
                            bullets.splice(j, 1);
                            
                            state.score += 100;
                            updateHUD();
                            break; 
                        }
                    }
                }
            }

            // 6. Boss Collisions
            if (boss && state.level === 2) {
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const b = bullets[j];
                    if (b.position.z < boss.position.z + 4 && b.position.z > boss.position.z - 4) {
                        if (Math.abs(b.position.x - boss.position.x) < 5) {
                            createExplosion(b.position, 0xffaa00);
                            state.bossHP -= 5; 
                            updateHUD();
                            
                            scene.remove(b);
                            bullets.splice(j, 1);

                            if (state.bossHP <= 0) {
                                createExplosion(boss.position, 0xffffff);
                                scene.remove(boss);
                                boss = null;
                                setTimeout(() => gameOver(true), 1000);
                            }
                        }
                    }
                }
            }

            // 7. Update Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.life -= 0.05;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();

    </script>
</body>
</html>